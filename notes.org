* Queries 19/10/18
** ImageDB passed in via ReaderT - is this the best idea?
** onload functionality for each image before continuing
Do this with an external JS function
** Splitting into library
** Unit tests for framework; how to test graphical stuff?
Will probably want to test functions operating on eDSL/AST to ensure they generate the correct structures
** USE ReaderT monad to capture fill/stroke state!
* Queries 16/10/18
** How to go about choosing a type of FRP
** Trouble with Haskell libraries (GHCjs)
Version hell
** Reflex FRP
* eDSL to represent presentations in Haskell using Functional Reactive Programming
** Design
*** DSL structure
*** Code generation
*** Target HTML/JS platform
**** Responsive design
**** Slides, prezi-style open area?
- Prezi-style open area with slides inside others promotes need for mouse interaction
- However having a "move the camera around" approach to things could open up lots of interesting other options
- "Slides" achieved by simply teleporting camera
- Should definitely have language to eliminate need to place slides
**** Placement of elements on slide
- Using co-ordinates is really horrible for most purposes
** Existing tech
*** reveal.js 
[[https://revealjs.com/#/]]
[[https://github.com/hakimel/reveal.js]]
*** Slideshow: Functional Presentations
http://www.cs.utah.edu/plt/publications/jfp05-ff.pdf
Not THAT relevant, but does some neat stuff (mostly static image composition with no reactive programming)
** Papers / web pages
*** reactive-banana walkthrough https://wiki.haskell.org/FRP_explanation_using_reactive-banana
** Libraries
* Tricky things
** chaining
Need to chain animations into each other, preserving properties set in previous tweens. 
Need some concept of object state at end of each Tween
Need to compare Tween objects to identify which is the same

Idea: accumulate object state through animations - only need to update it at the end of each animation

Idea: take the final object and extract its transforms by unwrapping the layers
Only remove the transform layers and keep everything else exactly the same

What I have: a list of AnimControl -> Content -> Content transforms
What I want: to leave untouched the transforms that aren't modified

Could: 
loop through transforms
remove any that are used - need to extract final value, though!
turn any that are unused into consts
** switching between chained animations
what i have: 
- for each stage of the animation, i have an Animation object that I can render
- a pure *updateAnimation* function which maps the state of an animation over time
- an Event (Animation -> Animation) *updateA'* which can be used to accumulate an animation state over time
  

ultimately want:
- Some concept of the *current* animation
- A single behaviour which I can render that shows the current Animation
- The ability to update the current animation through an event

in some way i gotta impose an order on the animations, so that on the appropriate event it knows how to go to the 'next' step
maybe list of Animations, current is defined by an integer?

want to have a behaviour which contains the current animation
then switch to update and render that animation


idea
make an accum function for each animation
the tick event only updates them when it's told to
also ability to reset animations


*SOLUTION*
- animationIndex behaviour that changes with clicks
- have a updateIfActive event that only updates the anim when animationIndex equals that animation's index 
- for each animation, accumulate with updateIfActive and store in list
- switch to return only currently active animation
- only render that animation

This only works for _one_ animation chain at the moment.
Solutions for multiple objects:
- multiple lists and index values
  - requires passing in separate lists of anims, one for each object
  - *problem* - don't want to run simultaneously!
- ?

ideally specify like this

animation 1
chain 1
animation 2
chain 2
chain 2
chain 1
etc

and each animation happens in the correct order
we render a set of animations rather than just the one

solutions:
make makeAnimation also return a unique key to specify which animation they belong to. then pass that key through chains
this can be used to separate into classes
also accumulate an order number which animations are tagged with through list of *all* animations

then have a separate list of anims for each class.
for each class of anims:
- render/update the *last* animation with an order key *less* than currentIndex
  
alternatively keep all animations in one list
then render+update *one* of each class moving backwards through the list from currentIndex

  
